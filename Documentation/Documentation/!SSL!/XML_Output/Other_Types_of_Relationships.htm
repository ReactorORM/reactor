<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml">
<!--(==============================================================)-->
<!--(Document created with RoboEditor. )============================-->
<!--(==============================================================)-->

<head>
  <title>Other Types of Relationships</title><!--(Meta)==========================================================-->
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <meta name="generator" content="RoboHelp by eHelp Corporation www.ehelp.com" />
  <meta name="generator-major-version" content="0.1" />
  <meta name="generator-minor-version" content="1" />
  <meta name="filetype" content="kadov" />
  <meta name="filetype-version" content="1" />
  <meta name="page-count" content="1" />
  <meta name="layout-height" content="1519" />
  <meta name="layout-width" content="1153" /><!--(Links)=========================================================-->
  <link rel="StyleSheet" href="default.css" />
</head><!--(Body)==========================================================-->

<body>
  <h1>Other Types of Relationships</h1>

  <p>Reactor has a few other tricks up its sleeves too. <!--kadov_tag{{<spaces>}}--> <!--kadov_tag{{</spaces>}}-->For instance, what if you wanted to know all the Customers associated with an address? <!--kadov_tag{{<spaces>}}--> <!--kadov_tag{{</spaces>}}-->Piece of cake! <!--kadov_tag{{<spaces>}}--> <!--kadov_tag{{</spaces>}}-->In this case, because one address can be associated with many Customers, an address "has many" customers. <!--kadov_tag{{<spaces>}}--> <!--kadov_tag{{</spaces>}}-->To facilitate this we'll add a hasMany relationship to our Reactor.xml configuration file.</p>

  <p> </p>

  <p class="code">&lt;reactor&gt;<br />
  <!--kadov_tag{{<spaces>}}-->    <!--kadov_tag{{</spaces>}}-->&lt;config&gt;<br />
  <!--kadov_tag{{<spaces>}}-->         <!--kadov_tag{{</spaces>}}-->&lt;project value="Scratch" /&gt;<br />
  <!--kadov_tag{{<spaces>}}-->         <!--kadov_tag{{</spaces>}}-->&lt;dsn value="Scratch" /&gt;<br />
  <!--kadov_tag{{<spaces>}}-->         <!--kadov_tag{{</spaces>}}-->&lt;type value="mssql" /&gt;<br />
  <!--kadov_tag{{<spaces>}}-->         <!--kadov_tag{{</spaces>}}-->&lt;mapping value="/ScratchData" /&gt;<br />
  <!--kadov_tag{{<spaces>}}-->         <!--kadov_tag{{</spaces>}}-->&lt;mode value="development" /&gt;<br />
  <!--kadov_tag{{<spaces>}}-->    <!--kadov_tag{{</spaces>}}-->&lt;/config&gt;<br />
  <br />
  <!--kadov_tag{{<spaces>}}-->    <!--kadov_tag{{</spaces>}}-->&lt;objects&gt;<br />
  <!--kadov_tag{{<spaces>}}-->         <!--kadov_tag{{</spaces>}}-->&lt;object name="Customer"&gt;<br />
  <!--kadov_tag{{<spaces>}}-->              <!--kadov_tag{{</spaces>}}-->&lt;hasOne name="Address"&gt;<br />
  <!--kadov_tag{{<spaces>}}-->                   <!--kadov_tag{{</spaces>}}-->&lt;relate from="addressId" to="addressId" /&gt;<br />
  <!--kadov_tag{{<spaces>}}-->              <!--kadov_tag{{</spaces>}}-->&lt;/hasOne&gt;<br />
  <!--kadov_tag{{<spaces>}}-->         <!--kadov_tag{{</spaces>}}-->&lt;/object&gt;<br />
  <br />
  <!--kadov_tag{{<spaces>}}-->         <!--kadov_tag{{</spaces>}}-->&lt;object name="Address"&gt;<br />
  <!--kadov_tag{{<spaces>}}-->              <!--kadov_tag{{</spaces>}}-->&lt;hasMany name="Customer"&gt;<br />
  <!--kadov_tag{{<spaces>}}-->                   <!--kadov_tag{{</spaces>}}-->&lt;relate from="addressId" to="addressId" /&gt;<br />
  <!--kadov_tag{{<spaces>}}-->              <!--kadov_tag{{</spaces>}}-->&lt;/hasMany&gt;<br />
  <!--kadov_tag{{<spaces>}}-->         <!--kadov_tag{{</spaces>}}-->&lt;/object&gt;<br />
  <!--kadov_tag{{<spaces>}}-->    <!--kadov_tag{{</spaces>}}-->&lt;/objects&gt;<br />
  &lt;/reactor&gt;</p>

  <p> </p>

  <p>This update has added a new object tag for the Address table to our configuration. <!--kadov_tag{{<spaces>}}--> <!--kadov_tag{{</spaces>}}-->This Address object has a "hasMany" tag that relates the Address to Customers via the addressId column in both tables. <!--kadov_tag{{<spaces>}}--> <!--kadov_tag{{</spaces>}}--></p>

  <p> </p>

  <p>So, if we create an AddressRecord object we'll see a new method on it. <!--kadov_tag{{<spaces>}}--> <!--kadov_tag{{</spaces>}}-->Go ahead and do that now. <!--kadov_tag{{<spaces>}}--> <!--kadov_tag{{</spaces>}}-->I'll wait for you to get back. <!--kadov_tag{{<spaces>}}--> <!--kadov_tag{{</spaces>}}-->Let me know what methods are new.</p>

  <p> </p>

  <p style="font-style: italic;">… Long Pause …</p>

  <p style="font-style: italic;"> </p>

  <p style="font-style: normal;">Ok. What'd you find? <!--kadov_tag{{<spaces>}}--> <!--kadov_tag{{</spaces>}}-->Ah ha! <!--kadov_tag{{<spaces>}}--> <!--kadov_tag{{</spaces>}}-->You're correct. <!--kadov_tag{{<spaces>}}--> <!--kadov_tag{{</spaces>}}-->The hasMany relationship caused one method to be generated: <span class="function">getCustomerIterator()</span></p>

  <p style="font-style: normal;">Without getting into too much detail, this method returns an object that allows you to easily iterate over and manipulate sets of related Records. <!--kadov_tag{{<spaces>}}--> <!--kadov_tag{{</spaces>}}-->In this case it represents the Address' Customers.</p>

  <p style="font-style: normal;"> </p>

  <p style="font-style: normal;">The Iterator object has several methods of note. <!--kadov_tag{{<spaces>}}--> <!--kadov_tag{{</spaces>}}-->We'll first focus on <span class="function">getQuery()</span> and <span class="function">getArray()</span>. <!--kadov_tag{{<spaces>}}--> <span class="function"><!--kadov_tag{{</spaces>}}-->GetQuery()</span> returns a query of the related customers. <!--kadov_tag{{<spaces>}}--> <span class="function"><!--kadov_tag{{</spaces>}}-->GetArray()</span> returns an array of CustomerRecords. <!--kadov_tag{{<spaces>}}--> <!--kadov_tag{{</spaces>}}-->Both of these methods accept optional arguments to limit the scope of the data returned. <!--kadov_tag{{<spaces>}}--> <!--kadov_tag{{</spaces>}}-->The signature of these two methods are:</p>

  <p style="font-style: normal;"> </p>

  <p style="font-style: normal;">query = getQuery(from, count)</p>

  <p style="font-style: normal;"> </p>

  <p style="font-style: normal;">array= getArray(from, count)</p>

  <p style="font-style: normal;"> </p>

  <p style="font-style: normal;">In both methods from and count are optional. <!--kadov_tag{{<spaces>}}--> <!--kadov_tag{{</spaces>}}-->From is the first row to return. <!--kadov_tag{{<spaces>}}--> <!--kadov_tag{{</spaces>}}-->Count is the number of rows to return.</p>

  <p style="font-style: normal;"> </p>

  <p style="font-style: normal;">For example, the following code will return a query of all the customers related to an AddressRecord:</p>

  <p style="font-style: normal;"> </p>

  <p class="code">&lt;cfset customers = AddressRecord.getCustomerIterator().getQuery() /&gt;</p>

  <p style="font-style: normal;"> </p>

  <p style="font-style: normal;">The next example will return only 5 records starting from the 10th record.</p>

  <p style="font-style: normal;"> </p>

  <p class="code">&lt;cfset customers = AddressRecord.getCustomerIterator().getQuery(10, 5) /&gt;</p>

  <p style="font-style: normal;"> </p>

  <p style="font-style: normal;">If the from and count arguments do not define a valid range then anything out side of the range will not be returned. <!--kadov_tag{{<spaces>}}--> <!--kadov_tag{{</spaces>}}--></p>

  <p style="font-style: normal;"> </p>

  <p style="font-style: normal;">Using the from and count is particularly useful when working with paginated lists of data. <!--kadov_tag{{<spaces>}}--> <!--kadov_tag{{</spaces>}}-->In fact, the Iterator object has methods for sorting and filtering data. <!--kadov_tag{{<spaces>}}--> <!--kadov_tag{{</spaces>}}-->The end result is the Iterator enables you to create applications which include sorting, filtering and paginating data.</p>

  <p style="font-style: normal;"> </p>

  <p style="font-style: normal;">The <span class="function">getArray()</span> method works just the same as the <span class="function">getQuery()</span> method, but it returns an array of records.</p> 

  <p class="note">Note: Iterators are backed by ColdFusion queries. <!--kadov_tag{{<spaces>}}--> <!--kadov_tag{{</spaces>}}-->Calling <span class="function">getArray()</span> translates rows in the query into record objects which are cached inside the Iterator. <!--kadov_tag{{<spaces>}}--> <!--kadov_tag{{</spaces>}}-->This means that even if you have a query of several thousand objects it's not terribly expensive to use <span class="function">getArray()</span> with the from and count arguments to translate a small subset of data into records. <!--kadov_tag{{<spaces>}}--> <!--kadov_tag{{</spaces>}}--></p>

  <p class="note"> </p>

  <p class="note">However, if you call <span class="function">getArray()</span> without the from and to arguments on anything more than a small set of data you may run into performance problems.<br />
   </p>

  <p style="font-style: normal;"> </p>

  <p style="font-style: normal;">Unlike the hasOne relationships, there is no <span class="function">setCustomerIterator()</span> method on the Address. This is because there's really nothing to set from the Address' perspective. The address doesn't have a field for customerId.</p>

  <p style="font-style: normal;"> </p>

  <p style="font-style: normal;">This all leads up to the next relationship type, Relationships via Linking Tables.</p>
</body>
</html>
